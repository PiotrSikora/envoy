# 1. Fix linking with unbundled toolchain on macOS.
# 2. Increase VSZ limit to 64 TiB (allows us to start up to 6,553 VMs).
# 3. Fix building and linking with MSAN.
# TODO(PiotrSikora): remove when not needed anymore (most likely in v9.2 branch):
# 4. Fix "thread_in_wasm flag was not set" crash in debug builds (https://chromium-review.googlesource.com/c/v8/v8/+/2817598, https://chromium-review.googlesource.com/c/v8/v8/+/2867468).
--- wee8/build/toolchain/gcc_toolchain.gni
+++ wee8/build/toolchain/gcc_toolchain.gni
@@ -348,6 +348,8 @@ template("gcc_toolchain") {
         # AIX does not support either -D (deterministic output) or response
         # files.
         command = "$ar -X64 {{arflags}} -r -c -s {{output}} {{inputs}}"
+      } else if (current_os == "mac") {
+        command = "\"$ar\" {{arflags}} -r -c -s {{output}} {{inputs}}"
       } else {
         rspfile = "{{output}}.rsp"
         rspfile_content = "{{inputs}}"
@@ -543,7 +545,7 @@ template("gcc_toolchain") {

       start_group_flag = ""
       end_group_flag = ""
-      if (current_os != "aix") {
+      if (current_os != "aix" && current_os != "mac") {
         # the "--start-group .. --end-group" feature isn't available on the aix ld.
         start_group_flag = "-Wl,--start-group"
         end_group_flag = "-Wl,--end-group "
--- wee8/src/objects/backing-store.cc
+++ wee8/src/objects/backing-store.cc
@@ -34,7 +34,7 @@ constexpr bool kUseGuardRegions = false;
 // address space limits needs to be smaller.
 constexpr size_t kAddressSpaceLimit = 0x8000000000L;  // 512 GiB
 #elif V8_TARGET_ARCH_64_BIT
-constexpr size_t kAddressSpaceLimit = 0x10100000000L;  // 1 TiB + 4 GiB
+constexpr size_t kAddressSpaceLimit = 0x400100000000L; // 64 TiB + 4 GiB
 #else
 constexpr size_t kAddressSpaceLimit = 0xC0000000;  // 3 GiB
 #endif
--- wee8/build/config/sanitizers/sanitizers.gni
+++ wee8/build/config/sanitizers/sanitizers.gni
@@ -150,7 +150,7 @@ if (!is_a_target_toolchain) {
 # standard system libraries. We have instrumented system libraries for msan,
 # which requires them to prevent false positives.
 # TODO(thakis): Maybe remove this variable.
-use_prebuilt_instrumented_libraries = is_msan
+use_prebuilt_instrumented_libraries = false

 # Whether we are doing a fuzzer build. Normally this should be checked instead
 # of checking "use_libfuzzer || use_afl" because often developers forget to
@@ -198,8 +198,7 @@ assert(!using_sanitizer || is_clang,
 assert(!is_cfi || is_clang,
        "is_cfi requires setting is_clang = true in 'gn args'")

-prebuilt_instrumented_libraries_available =
-    is_msan && (msan_track_origins == 0 || msan_track_origins == 2)
+prebuilt_instrumented_libraries_available = false

 if (use_libfuzzer && (is_linux || is_chromeos)) {
   if (is_asan) {
--- wee8/build/config/compiler/BUILD.gn
+++ wee8/build/config/compiler/BUILD.gn
@@ -736,11 +736,6 @@ config("compiler") {
     cflags += [ "-fcomplete-member-pointers" ]
   }

-  # TODO(crbug/1185183): Remove after next clang roll
-  if (is_clang && !is_nacl && is_linux && is_msan) {
-    cflags += [ "-flegacy-pass-manager" ]
-  }
-
   # Pass the same C/C++ flags to the objective C/C++ compiler.
   cflags_objc += cflags_c
   cflags_objcc += cflags_cc
--- wee8/src/execution/isolate.cc
+++ wee8/src/execution/isolate.cc
@@ -1672,10 +1672,36 @@ Object Isolate::ReThrow(Object exception) {
   return ReadOnlyRoots(heap()).exception();
 }

+namespace {
+// This scope will set the thread-in-wasm flag after the execution of all
+// destructors. The thread-in-wasm flag is only set when the scope gets enabled.
+class SetThreadInWasmFlagScope {
+ public:
+  SetThreadInWasmFlagScope() {
+    DCHECK_IMPLIES(trap_handler::IsTrapHandlerEnabled(),
+                   !trap_handler::IsThreadInWasm());
+  }
+
+  ~SetThreadInWasmFlagScope() {
+    if (enabled_) trap_handler::SetThreadInWasm();
+  }
+
+  void Enable() { enabled_ = true; }
+
+ private:
+  bool enabled_ = false;
+};
+}  // namespace
+
 Object Isolate::UnwindAndFindHandler() {
+  // Create the {SetThreadInWasmFlagScope} first in this function so that its
+  // destructor gets called after all the other destructors. It is important
+  // that the destructor sets the thread-in-wasm flag after all other
+  // destructors. The other destructors may cause exceptions, e.g. ASan on
+  // Windows, which would invalidate the thread-in-wasm flag when the wasm trap
+  // handler handles such non-wasm exceptions.
+  SetThreadInWasmFlagScope set_thread_in_wasm_flag_scope;
   Object exception = pending_exception();
-  DCHECK_IMPLIES(trap_handler::IsTrapHandlerEnabled(),
-                 !trap_handler::IsThreadInWasm());

   auto FoundHandler = [&](Context context, Address instruction_start,
                           intptr_t handler_offset,
@@ -1768,9 +1794,10 @@ Object Isolate::UnwindAndFindHandler() {
                             StandardFrameConstants::kFixedFrameSizeAboveFp -
                             wasm_code->stack_slots() * kSystemPointerSize;

-        // This is going to be handled by Wasm, so we need to set the TLS flag.
-        trap_handler::SetThreadInWasm();
-
+        // This is going to be handled by WebAssembly, so we need to set the TLS
+        // flag. The {SetThreadInWasmFlagScope} will set the flag after all
+        // destructors have been executed.
+        set_thread_in_wasm_flag_scope.Enable();
         return FoundHandler(Context(), wasm_code->instruction_start(), offset,
                             wasm_code->constant_pool(), return_sp, frame->fp());
       }
--- wee8/src/compiler/wasm-compiler.cc
+++ wee8/src/compiler/wasm-compiler.cc
@@ -7030,6 +7030,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {

     BuildModifyThreadInWasmFlag(true);

+    Node* old_effect = effect();
     Node* exception_branch = graph()->NewNode(
         mcgraph()->common()->Branch(BranchHint::kTrue),
         gasm_->WordEqual(return_value, mcgraph()->IntPtrConstant(0)),
@@ -7046,9 +7047,8 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     gasm_->Call(call_descriptor, call_target, return_value);
     TerminateThrow(effect(), control());

-    SetEffectControl(
-        return_value,
-        graph()->NewNode(mcgraph()->common()->IfTrue(), exception_branch));
+    SetEffectControl(old_effect, graph()->NewNode(mcgraph()->common()->IfTrue(),
+                                                  exception_branch));
     DCHECK_LT(sig_->return_count(), wasm::kV8MaxWasmFunctionMultiReturns);
     size_t return_count = sig_->return_count();
     if (return_count == 0) {
